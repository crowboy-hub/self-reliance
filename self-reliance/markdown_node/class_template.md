# 模板
c++特点
面向对象
泛型编程，利用的技术是模板

## 函数模板

* 函数模板利用关键字 template
* 使用函数模板有两种方式：自动类型推导、显示指定类型
* 模板的目的是为了提高复用性，将类型参数化

### 普通函数与函数模板区别：

* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换
  总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T

### 普通函数与函数模板的调用规则如下：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配,优先调用函数模板
总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

### 函数重载的两种特殊情况
* 引用作为重载条件
* 函数重载碰到函数默认参数
（这部分以后遇到可以看视频）


模板在person（自定义数据类型）中的使用
如比较函数，一个person中存在多个数据类型，这个时候模板T不知道该是什么了。
**处理方法**   
 1. ==号的运算符重载
 2. person的具体化
 ```cpp
 template<class T>
bool myCompare(T& a, T& b)
 template<> bool myCompare(Person &p1, Person &p2)
```

## 类模板
```cpp
//声明
template<class type1,class type2>
class person
{
public(type1 name,type2 age)

type1 m_name;
type2 m_age;
}
```
```cpp
//使用
person<string,int>p1("jack",38);
```
类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数
```cpp
template<class type1,class type2=int>
//在创建模板的时候就默认了type2的参数是int，这样之后使用的时候就不用再说了
person<string>p1("jack",38);
```
### 类模板中的成员函数只有在调用的时候才会创建
即：虽然在类模板中声明了成员函数，（如不同成员函数原来的使用对象不同），那么只有在真正调用的时候，才知道这个成员函数他原来的对象是哪个，才会真正地创建。

### 类模板对象做函数参数
```cpp
没听懂
```
### 类模板与继承
当类模板碰到继承时，需要注意一下几点：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中T的类型，子类也需变为类模板
```cpp
template <class T>
class base
{
	T m;
};
//方法一，进行具体的指定，不灵活
class son:public base<int>   //这里指定了T的类型
{
};

//方法二，灵活，子类也变成类模板
template <class T1,class T2>
class son2:public base<T 2>
{
public :
	son2()
	{	cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
T1 obj;
};
//方法二在调用的时候才具体设置类型，所以灵活
void test1()
{	
	son2<int ,char> child;
}
//int 指定了T的类型，char通过T2指定了父类中T的类型
```

### 类模板成员函数的类外实现
解决的问题就和普通类，他的成员函数不放在类声明内部，而是放在外面实现一样。
我认为无论是构造函数还是成员函数，类模板和普通类的区别在于：
1. 这些函数都看成是一种函数模板
2. 在具体调用的时候对类型进行指定
```cpp
template <class T1,class T2>
class person
{
public：
	person（T1 name,T2 age）；
	void showperson();//成员函数
}；
//构造函数的实现
template <class T1,class T2>
person<T1,T2>::person(T1 name,T2 age)
{
}
//成员函数的实现
template<class T1,class T2>  //为了让编译器认识下面的T1,T2
void person<T1,T2>::showperson()
{
}
//调用的时候进行指定
void test1()
{ 
	person<string,int> p("TOM",10);
	p.showperson();
}

```
### 类模板分文件编写
一个程序中含有多个类时，通常将每个类分别写在一个头文件中。
一般声明和实现分开两个文件写，即.h和.cpp
这里由于涉及编译的问题，记住就行。把声明和实现都写在一个文件里面，即.h中。

### 类模板与友元
全局函数类外实现有点复杂，涉及编译顺序的问题。要写就写全局函数的类内实现得了。
这部分有点糊涂，甚至是全局函数的类内实现，以后用到再说吧。


# 容器
## string
## vector
vector成为单端数组，与普通数组的不同在于：普通数组是静态数组，而vector是动态数组

1. v1.begin()   类型并不是int型，begin指的是第一位置。类似数组中开始处0的位置。end指的是最后一个数的后一位
2. vector利用swap来压缩空间

```cpp
//这里vector<int>(v1)是一个匿名对象，该对象与v1进行swap，而后系统会自动收回匿名对象
//所占用的空间
vector<int>(v1).swap(v1);   
```
3. 动态扩展，将原有空间中的数据拷贝到新空间下，而后再释放原有空间。
```cpp
//利用每次动态扩展后都会开辟新的空间，这样v1[0]的地址就会变，
//根据变化的次数可以得出进行了多少次动态扩展
vector<int> v1;
int num=0;//统计动态扩展的次数
int* p = NULL;
for (int i = 0; i < 100; i++)
{
	v1.push_back(i);
	if (p != &v1[0])
	{
		num++;
		p = &v1[0];
	}
}
printvector(v1);
cout << num << endl;
```
## deque
1. deque内部的中控器记录着各个缓冲区的地址，这样“连”起来，使得deque用起来就像一片连续的内存空间。
2. 和vector一样支持随机访问，也就是可以跳跃式地访问内部元素。
3. deque没有容量的概念。
4. erase操作删除的 earse(1,3)。真正删除的是从1开始到3之前的内容。
5. insert erase这类操作中的pos的数据类型不是int，因此不能用简单的3来代替，而是d.begin()+3这种。
## stack
1.栈 先进后出，不允许有遍历行为(遍历的不允许栈中有元素改变的）。只有栈顶元素才能被访问到。

## queue
1. 队列先进先出，不允许有遍历行为。一端只能进，一端只能出。
2. queue不提供迭代器，不支持随机访问。

## list
1. list由结点组成，每个结点由数据域和指针域组成。数据域中是要维护的数据，结点域中是指向下一个节点的指针，这样就一个个连起来了
2. 优点：可以对任意位置进行快速的插入和删除。动态存储分配，不会造成内存的浪费和溢出。
3. 缺点：遍历起来速度没有数组快，占用内存更多
4. 链表的存储空间不是连续的，因为其迭代器不能直接begin（）+3来访问。是双向迭代器，只支持前移和后移。
5. STL中的链表为双向循环链表。
6. 特殊：list中insert和erase操作，pos要使用迭代器    
7. list.remove(10)：删除了list中所有与10相同的
8. 大纲list容器中不可以通过[]或者at方式访问数据       
	返回第一个元素   --- front     
	返回最后一个元素   --- back
9. //所有不支持随机访问迭代器的容器，不能使用标准算法库algorithm
	//这些不知道随机访问迭代器的容器，内部会提供一些相应的算法

## set/multiset容器
1. 关联式容器，插入时会自动排序。
2. set与multiset的区别在于set不允许容器中有重复元素，而multiset允许。
3. 

## map容器
1. map所有容器多是pair，第一个元素是key值，第二个元素为value值。
2. 所有元素都会根据key值自动排序
3. map与multimap的区别：是否允许重复的key值元素


# 回调函数
[理解](https://www.runoob.com/w3cnote/c-callback-function.html)

降低耦合度，哇，真是不错的技术。有意思，我以前也思考过如何解决这样的问题。
# 思考
1. 感觉迭代器的使用好笨拙。++或者--，如果要跨很大的区域呢，这应该怎么办
2. map自定义数据类型排序虽然运行通了，但是不理解仿函数的调用机制是什么样的。

# Odd Notes
1. 字符c在自动类型转换（隐式类型转换）后，对应是一个数字，a=97，ASCII码
2. 

# Bug Notes
1. 数组不能用引用   即&a[ i]。
2. 
